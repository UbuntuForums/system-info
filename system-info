#!/bin/bash

## MAFoElffen, <mafoelffen@ubuntu.com>, 2021.08.19
## 
## Contributors:
##     sudodus <nio.wiklund@gmail.com>, 2021.08.25
##     Doug S,  2021.08.22
##     oldfred, 2021.08.20
## Filename: support-info
## Description: Report Finds Machine System And Hardware Related Information.
## Purpose:     For support use at "UbuntuForums.org".
#########################################################################
#  Copyright (c) 2012, 2021
#
#  GNU General Public License (GPL-3.0-or-later)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#


########################################################################
#### Variables
########################################################################
# Versioning
version="Version: 02.00-09, Script Date: 2023.11.28"
exit_code=0
#md5_sum=$(md5sum $sname | sed 's/system.*//g' )
arg1=$1
arg2=$2
# Set Report filename and path to
sname="${0##*/}"   # flexible, needs quoting everywhere if spaces
report="$HOME/${sname}.txt"
#  Get present Locale settings
localectl_status=$(localectl status  )
locale_state=$(locale )
LANG_Hx=$LANG
LC_CTYPE_Hx=$LC_CTYPE
# Set locale language settings
LANG=C
LC_CTYPE=C
# Set a pretty ANSI screen decoration for displaying the report onscreen
blueback="\0033[1;37;44m"
redback="\0033[1;37;41m"
faintvid="\0033[2m"
resetvid="\0033[0m"
# Check boot mode
boot_mode=$( [ -d /sys/firmware/efi ] && echo "UEFI Firmware mode" || echo "Legacy mode (alias CSM alias BIOS mode)" )
boot_status=$( [ -d /sys/firmware/efi ] );    # Use boot mode as boolean test
less_status="less"
up_status= "true"
debian_branch=0
# Report timestamp
startt="$(date '+%F  %T %Z (%z)')"
# LST Name for package calc
LTS_PKG=""
# variables to keep track of missing programs...
missing_programs=""
check_paster=0
# Variable to track upload status as uploaded
check_paste=1
missing_paster_progs=""
# Variable to add more detail to Report
detail_level='-v'
bios_detail=1
zfs_detail=1
md_detail=1
lvm2_detail=1
btrfs_detail=1
# Logger settings
#     Change verbosity to show level of warnings. Range: -1 through 5. -1 is show nothing.
verbosity=-1
silent_lvl=0
crt_lvl=1
err_lvl=2
wrn_lvl=3
inf_lvl=4
dbg_lvl=5

# Trap Control-C
stty -echoctl # hide ^C
trap 'other_commands' SIGINT

# 'Trap Section' to clean up Temporary Files on unexpected EXIT's
trap "rm -f $manually_installed" EXIT 2> /dev/null
trap "rm -f $default_installed" EXIT 2> /dev/null
trap "rm -f $user_installed" EXIT 2> /dev/null
trap "rm -f $ssh_data" EXIT 2> /dev/null
trap "ResetLocale" EXIT 2> /dev/null

########################################################################
#### Functions:
########################################################################
function other_commands()
{
    tput setaf 1
    printf "You can 'not' exit this script by pressing Control-C..."
    tput sgr0
    printf "Continue with last 'asked' input..."
}

function CheckRoot()
{
    clear -x;
    ## Check if ran as root. Runs at startup. Called by Main()
    if [[ "$EUID" == 0 ]] || [ $UID -eq 0 ]
    then 
        echo -e "$redback Do not run this script with sudo or as root$resetvid"
        echo -e "If your Linux distribution installs with only a Root User as a default, "
        echo -e "please create another User that has the ability to run elevated commands. "
        PassPhrase
        #exit_code=106
        #exit $exit_code
        echo -e "Running Script: ${sname} $version"
    else
        echo -e "This script needs some parts of it to run with elevated permissions."
        nl
        ## Check if 'sudo' is installed...
        if type sudo > /dev/null 2> /dev/null
        then
           echo -e "Please enter your password for that to happen."
           sudo -k # revoke previously cached sudo password 
            if sudo true
            then 
                echo -e "Running Script: ${sname} $version"
            else 
                echo -e "$redback ----------- This script is made to use 'sudo' ----------- $resetvid"
                echo -e "$redback ---- Password was incorrect for sudo elevated rights. --- $resetvid"
                PassPhrase
                echo -e "Continuing to run the script, but: Expect errors. "
            fi
        else
            echo -e "$redback ----------- This script is made to use 'sudo' ----------- $resetvid"
            echo -e "$redback        This system does not have 'sudo' installed.        $resetvid"
            echo -e "$redback If you install 'sudo' you will get much more information. $resetvid"
            Pause
            echo -e "Running Script: ${sname} $version"
        fi
    fi
}

function CheckArgs()
{
    # Version or Help Panel. Called by Main().
    if [[ "$arg1" == "-v" ]]
    then
        # Versioning: At the commandline: [<ScriptName> -v] returns <VersionInfo>, then exits. 
        echo -e "$version";
        ResetLocale
        exit;
    elif [[ "$arg1" == "-h" ]] || [[ "$arg1" == "--help" ]]
    then
        # Help Panel: At the commandline: [<ScriptName> -h or --help] returns this usage panel, then exits. 
        echo "Running Script: ${sname} $version"
        echo -e "md5sum: "$(md5sum ${sname} | sed 's/system.*//g' )
        nl
        echo -e "Description: The Ubuntu Forums \"system-info\" script queries the users "
        echo -e "computer and prepares a report, so that Ubuntu Forums Community Members "
        echo -e "can see what they are recommending solutions for."
        nl
        echo -e "Usage:    ./${sname} <option> "
        nl
        echo -e "Options: "
        echo -e "    -v              Returns Version Information and exits."
        echo -e "    -h or --help    Displays this Help Screen, then exits."
        echo -e "    -s # or --show  #  Changes Verbosity levels of the logger."
        echo -e "        # range 0 through 5"
        echo -e "        Example: system-info -s 5  turns on debugging messages"
        echo -e "    -d or --details Displays more details to Report"
        echo -e "        Adds more details to GPU,Storage Controller, Sound devices, "
        echo -e "            and ZFS (if installed)."
        echo -e "    -r or --refresh Update script to latest version."
        nl
        echo -e "Parts of the script need elevated permissions (sudo) to get the correct " 
        echo -e "information from your system, while other parts do not. We have "
        echo -e "determined where that needs to be used and when not. While the script is "
        echo -e "running, you will be asked to enter your userID's password."
        nl
        echo -e "It then asks the user 2 questions to describe the problem they are having, "
        echo -e "then creates ${sname}.txt in their Home directory."
        nl
        echo -e "Will check programs used by this script, and give the user the option to "
        echo -e "quit to install anything it finds missing. Will give the user the option "
        echo -e "to upload the report to a pastebin and displays the URL of that to add "
        echo -e "their post on Ubuntu Forums."
        nl
        echo -e "Or they can manually paste the report within code tags in a post or to a "
        echo -e "pastebin. Or added as a text attachment to a post."
        nl
        echo -e "We have tried to keep this safe and simple to use."
        ResetLocale
        exit;
    elif [[ "$arg1" == "-s" ]] || [[ "$arg1" == "--show" ]]
    then
        if [ $arg2 -ge -1 ] && [ $arg2 -le 5 ]
        then 
            verbosity=$arg2
        else
            echo -e "Startup Option out of range."
            ResetLocale
            exit_code=1
            exit $exit_code;
        fi
    elif [[ "$arg1" == "-d" ]] || [[ "$arg1" == "--details" ]]
    then 
        detail_level='-vv'
        zfs_detail=0
        bios_detail=0
        md_detail=0
        lvm2_detail=0
        btrfs_detail=0

    elif [[ "$arg1" == "-r" ]] || [[ "$arg1" == "--refresh" ]]
    then 
        RefreshScript
        Pause
        exit_code=0
        exit $exit_code
    fi
}

function ResetLocale() {
    LANG=$LANG_Hx
    LC_CTYPE=$LC_CTYPE_Hx  
}

function CheckTypeError() {
   type -a type > /dev/null 2>&1
   TypeError=$?
   if [[ "$TypeError" == "1" ]]
   then
       echo -e "The 'type' command is not found as an internal builtin command on this "
       echo -e "system. Cannot check for prerequisite Linux utilities used in this script."
       echo -e "This script will run, but may display some errors."
       nl
   fi
   unset -v TypeError
}

function RefreshScript() {
    # Upgrade script in-place
    SOURCE=${BASH_SOURCE[0]}

    while [ -L "$SOURCE" ]
    # resolve $SOURCE until the file is no longer a symlink
    do 
        DIR=$( cd -P "$( dirname "$SOURCE" )" > /dev/null 2>&1 && pwd )
        SOURCE=$(readlink "$SOURCE")
        if [[ $SOURCE != /* ]] 
        then 
            SOURCE=$DIR/$SOURCE
        fi 
    done

    DIR=$( cd -P "$( dirname "$SOURCE" )" > /dev/null 2>&1 && pwd )

    cd $DIR

    sudo wget -N -t 5 -T 10 https://github.com/UbuntuForums/system-info/raw/main/system-info
    sudo chmod +x system-info
    echo -e "Script was refreshed."
    nl
    unset DIR SOURCE
}

function CheckDebianBranch()
{
    # Check if OS is in Debian Branch
    # var debian_branch is global
    if [ -f /etc/debian_version ]
    then
        debian_branch=0
    else
        debian_branch=1
    fi
    debug "CheckDebianBranch(). Value: $debian_branch" 1
}

function CheckUbuntuFlavor()
{
    # Check if OS is an Ubuntu Flavor
    ubuntu_found=$(grep -m 1 -Ei 'untu' /etc/*release)
    #echo -e "${#ubuntu_found[@]}"

    if [[ "$ubuntu_found" == *"untu"* ]]
    then
        ubuntu_flavor=0
    else
        ubuntu_flavor=1
    fi
    debug "CheckUbuntuFlavor(). Value: $ubuntu_found" 1
    # var ubuntu_flavor is global
    unset -v ubuntu_found
}

function GetReleaseDescription()
{
   # Retrieve 'Release Description' from a Linux Operating System
   # As an alternative to: echo -e "The current release description is: ${setansi} $(lsb_release -sd) $ransi"
   # Called from GetOtherDetails()
   
   if [[ "$check_lsb_release" == "0" ]]
   then
       os_name=$(lsb_release -sd)
       debug "Got release description from 'lsb_release'." 1
   else
       # Parse through the (possibly) many release file candidates to retrieve the answer...
       os_name=$(grep -m 1 'PRETTY_NAME|DISTRIB_DESCRIPTION' /etc/*release | \
           sed 's/\/etc\/.*release://g' | \
           sed -e 's/[Pp][Rr][Ee][Tt][Tt][Yy]_[Nn][Aa][Mm][Ee]=//g'  \
               -e 's/[D,d][E,e][S.s][C,c][R,r][I,i][P,p][T,t][I,i][O,o][Nn]=//g' | \
           sed 's/\"//g')
      nl
      debug "Got release description from 'release' file" 1
   fi
   
   echo -e "    --- Operating System Release Description --- "
   
   if [[ "$os_name" == "" ]]
   then
       echo -e "There was a problem determining the Release Description... "
       echo -e "Here is the raw output of the release file(s) to determine manually:"
       grep --color=never '=' /etc/*release
       debug "GetReleaseDescription(). Dumped release file info. Condition failed." 1
   else
       echo -e "The current release description is: ${setansi} $os_name $ransi"
   fi
   
   nl
   unset -v os_name
}

function CheckPrerequisites()   
{
    ## Check if all necessary programs are available. Called once by Main().
    # Programs that are in /bin or /usr/bin.
    Programs='
        sudo
    	cat
    	grep
    	awk
    	free
    	gsettings
    	gzip
    	tar
    	md5sum
    	mokutil
    	curl
    	pastebinit
    	ubuntu-drivers
    	comm
    	dpkg
    	nc
    	wget
    	less
    	ls
    	lshw
    	lspci
    	lsb_release
    	stat
    	stdbuf
    	rm
    	sed
    	ping
    	id
    	hostname
    	hostnamectl
    	pstree
    	lsblk
    	lsusb
    	sleep
    	sort
    	mktemp
    	whoami
    	who'

    # Programs that are in /usr/sbin or /sbin.
    Programs_SBIN='
        fdisk
        ip'

    # Programs that are in /usr/snap/bin.
    Programs_SnapBin='
        curl'
        
    check_prog=1; # global scope
    check_mokutil=1; # global scope
    check_lshw=0; # global scope
    check_lsb_release=0; # global scope
    check_hostname=0; # global scope
    
    CheckDebianBranch
    CheckUbuntuFlavor

    for Program in ${Programs} ${Programs_SBIN}
    do
        if [ $(type ${Program} > /dev/null 2>&1 ; echo $?) -ne 0 ]
        then
            ## Added to check if a program is not in bin or sbin, but might be present in Snap
            #    I might have to replicate this for Flatpak(?)
            #    Renamed variable $Program in this stub here to ProgramSof (for "Program: Snap Or Flatpak".
            for ProgramSoF in ${Programs_SnapBin}
            do
                snap_test=$(snap list $ProgramSof 2>&1 )
                snap_exit=$?
                flatpak_test=$(flatpak list $ProgramSof 2>&1 )
                flatpak_exit=$?

                ## This first part is more generic code for future things moved to the Snap Store...                
                #if [[ "$snap_test" != *"no matching snaps installed"* ]] || [ $snap_exit -eq 0 ]
                #then
                #    check_prog=0;
                #    debug "$ProgramSoF found in Snap" 1
                #elif [[ "$flatpak_test 2>&1 )" != "no matching flatpaks installed" ]] || [ $flatpak_exit -eq 0 ]
                #then
                #    check_prog=0
                #    debug "$ProgramSoF found in FlatPak" 1
                #else
                #    debug "$ProgramSoF not found in an Alternative Package Store" 1
                #fi
                ##
                
                # This part is just for now, where 'curl' might be from Snap
                if [[ "$ProgramSoF" == "curl" ]]
                then
                    if [ -e /usr/bin/curl ] || [ -e /snap/bin/curl ]
                    then
                        check_prog=0
                        debug "'curl' was found in either /usr/bin or /snap/bin" 1
                    elif [ $snap_exit -eq 0 ]
                    then
                        check_prog=0
                        debug "'curl' found in Snap" 1
                    elif [ $flatpak_exit -eq 0 ]
                    then
                        check_prog=0
                        debug "'curl' found in Flatpak" 1
                    else
                        check_prog=1
                        debug "'curl' was not found in either /usr/bin or /snap/bin" 1
                    fi
                fi
            done
            ## Cleanup Local Variables
            unset -v snap_test snap_exit flatpak_test flatpak_exit ProgramSoF Programs_SBIN

            if [[ "$check_prog" == "1" ]]
            then
                echo -e " --- Some Programs This Script Uses Were Missing --- "
            fi
            if [[ "$Program" == "mokutil" ]]
            then    # If not 'Here' condition
                # If this missing, it is a variant for UEFI systems only. It does work on 18.04 where it was not default yet, and is 
                # a useful option to see if there "is" a SecureBoot option in the BIOS, besides just what it is set at. This, during 
                # tests, is safe to install on Legacy Only BIOS systems and can be used to tell if the BIOS is such.
                echo -e "$faintvid \"${Program}\" Could not be found. This program is suggested.$resetvid" 
                echo -e "$faintvid If this is older hardware that is 'Legacy Only BIOS', then this can be $resetvid"
                echo -e "$faintvid ignored. The report will still run without it. It will just not be able $resetvid"
                echo -e "$faintvid to answer one question. $resetvid"
                check_mokutil=0;    # Set Flag to false and recheck in GetSb()
                check_prog=0;
                missing_programs="$missing_programs\n$Program"
                debug "'$Program' is not installed" 1
            elif [[ "$Program" == "pastebinit" ]] || [[ "$Program" == "wget" ]] || [[ "$Program" == "curl" ]] || [[ "$Program" == "nc" ]]
            then
                check_prog=0;
                check_paster=$((check_paster+1));
                missing_paster_progs="$missing_paster_progs$Program, "
                missing_programs="$missing_programs\n$Program"
            # To take care of a permissions check issue on Debian, 2022.06.15
            elif [[ "$Program" == "fdisk" ]]
            then
                #LSB_ID=$(lsb_release -si)
                if [[ "$debian_branch" == "0" ]]
                then
                    # Set Debian as an exception
                    check_prog=0;
                    debug "System is Debian, 'fdisk'" 1
                fi
                if [ -e /sbin/fdisk ]
                then
                    check_prog=0
                    debug "'fdisk' is in /sbin" 1
                fi
            elif [[ "$Program" == "ip" ]]
            then
                # For Slackware
                if [ -e /sbin/ip ]
                then
                    check_prog=0
                    debug "'ip' is in /sbin" 1
                fi
            elif [[ "$Program" == "lspci" ]]
            then
                # For Slackware. lspci is in /sbin, instead of /bin
                if [ -e /bin/lspci ]
                then
                    #lspci_cmd="/bin/lspci"
                    check_prog=0
                    debug "'lspci' is in /bin" 1
                elif [ -e /sbin/lspci ]
                then
                    #lspci_cmd="/sbin/lspci"
                    check_prog=0
                    debug "'lspci' is in /sbin" 1
                else 
                    #lspci_cmd="lspci"
                    debug "'lspci' was not found." 1
                fi
            elif [[ "$Program" == "lsb_release" ]]
            then
                # CHANGE - Do not assume all Debian Branch uses 'lsb_release'...
                # If 'lsb_release' does not exist, then set flag for it.
                # Set/call alternate methods to retrieve System Description information
                ## GetReleaseDescription() Modified for this
                #check_prog=0;
                check_lsb_release=1
                debug "Utility 'lsb_release' is not here" 1
            elif [[ "$Program" == "hostname" ]]
            then
                if [ -e /usr/bin/hostnamectl ]
                then
                    check_prog=0
                    check_hostname=1
                else
                    check_hostname=2
                    debug "Both 'hostname' and 'hostnamectl' where not found." 1
                fi
            elif [[ "$Program" == "ubuntu-drivers" ]]
            then
                # Check if it is Ubuntu Flavor, else not needed
                if [[ "$ubuntu_flavor" == "1" ]]
                then
                    check_prog=0;
                    echo -e "'ubuntu-drivers' is not installed, but is not an Ubuntu Flavor, so ignore."
                fi
            elif [[ "$Program" == "dpkg" ]]
            then
                # Check if Debian Branch, else not needed
                if [[ "$debian_branch" == "1" ]]
                then
                    check_prog=0;
                    echo -e "'dpkg' is not installed, but ignore, as this is not a Debian Branch."
                fi
            elif [[ "$Program" == "lshw" ]]
            then
                check_lshw=1
                check_prog=0;
                echo -e "'lshw' is not installed, but will run with less details."
            else
                echo -e "'$Program' is not installed."
                check_prog=0;
                missing_programs="$missing_programs\n$Program"
            fi
        fi
    done
    
    if [ "$check_prog" == 0 ]
    then
        echo -e " -------------------------------- "
        nl
        echo -e "The Script 'system-info' uses some very basic Linux utilities. "
        echo -e "Some of these utilities were not found."
        nl
        echo -e "The report will still run without them. It will just not answer related "
        echo -e "questions. Some of that information may be related to the diagnosis of "
        echo -e "your installed system. If missing utilities may have answered your "
        echo -e "specified problem, you may be asked by a 'Ubuntu Forums Member' supporting "
        echo -e "you if a program was missing, and if you could install it to answer that "
        echo -e "related question."
        nl
        CheckPaster
        echo -e "Some of these utilities are not default installed utilities to all Editions, "
        echo -e "versions, and flavors of Ubuntu... So may be considered as optional. "
        nl
       
        ans=
        while [ "$ans" != "e" ] && [ "$ans" != "E" ] && [ "$ans" != "c" ] && [ "$ans" != "C" ]
        do
            read -erp "<E>xit and install the program(s) or <C>ontinue anyway? <E/C> " ans 
            ans="${ans,}" 
            debug "User answered $ans" 1
            if [[ $ans =~ ^[Ee]$ ]]
            then
                echo -e "Please install the missing programs listed above before rerunning script." 
                debug "User choose to exit after missing programs." 1
                ResetLocale
                exit_code=0
                exit $exit_code
            elif [[ ${ans,} =~ ^[Cc]$ ]]
            then
                echo -e "Some task(s) will not work, but I'll do the best possible, continuing ..." 
                debug "User choose to continue while missing some programs." 1
                sleep 1
            fi
        done
    else
        echo -e "All required programs installed..."
        sleep 1
    fi
}

function CheckPaster() {
    if [ $check_paster -eq 4 ]
    then
        echo -e "Programs 'pastebinit', 'curl', 'wget', and 'nc' are missing. "
        echo -e "All 4 utilities used to upload this report to a PasteBin are missing."
        echo -e "The report will still run. If not installed, you would just need to "
        echo -e "paste the report into a post, contained within 'CODE' Tags."
        nl
    fi
    if [ $check_paster -le 3 -a $check_paster -ge 1 ]
    then
        echo -e "Program(s) $missing_paster_progs is/are missing, "
        echo -e "but can be ignored as there still are installed utilities present to "
        echo -e "to be able to upload the report to an online PasteBin."
        nl
    fi  
}

function ProcessMissingPrograms() {
    echo -e "---- Required Programs For Report."
    if [[ "$missing_programs" == "" ]]
    then
        echo -e "    All required programs installed for report. "
        nl
    else
        echo -e "    --- Some Programs This Script Uses Were Missing --- "
        echo -e "$missing_programs" | awk 'NF && !/^(start|#)/ {print "    " $0}'
        nl
    fi
}

function RmOldReport()  
{
    # Removes the old report. Called once by Main().
    /bin/rm -f "$report"
    exit_code=$?
    debug "Remove old report. Exit code: $exit_code" 1
}

function UserInput()
{
    # Gather User Information on the problem. Called once by Main()
    # User Input for Problem and Description
    # Format input
    width=$(tput cols)
    str=
    for ((i=1; i<=$width; i++))
    do 
        str="${str}_"
    done
    #echo -e "$str"
    nl
    echo -e "Please provide some \"Basic Information\"..."
    read -erp "What is the Main Complaint (summarized)? " main_complaint
    read -erp "Describe the Problem: " problem_description
    clear -x
    unset -v i cols width str
}

function GetMachineInfo()
{
    # Gets Computer Information. Called once by Writer().
    GetCPU
    GetDmi
    GetMem
    GetSwap
    GetNetworkingInfo
    GetHostname
    nl 
}

function GetCPU()
{
    # Gets CPU Information. Called once by GetMachineInfo().
    echo -e "${setansi}---------- General Computer Specifications:$ransi"
    nl
    # Do not call $lshw_cmd if 'lshw' is not installed... 
    if [[ "$check_lshw" == "0" ]]
    then
        echo -e "  --- Computer/CPU Information from 'lshw -C cpu' --- "
        $lshw_cmd -C cpu \
            | sed -r '/^  *([a-z])/ s/([a-zA-Z])/\u&/' \
            | sed -e 's/^ *\*-cpu/\*-Cpu/g' \
            | sed '/Capabilities/ s/ *Capabilities/  Capabilities/' \
            | fold -sw 71 \
            |sed -e 's/^[^ ]/           &/' \
            -e 's/ *\*-Cpu/\*-Cpu/g' \
            -e 's/ Capabilities/   Capabilities/' \
            -e 's/       /    /' \
            -e '/Capabilities/ s/^[^ ]/          &/'
        nl
        $lshw_cmd \
            | sed '/*-core/,$ d' \
            | sed -r '/^  *([a-z])/ s/([a-zA-Z])/\u&/' \
            | sed -e 's/ *Configuration/ Configuration/' \
            -e '/Configuration/ s/ [^ ]*=[^ ]*/\n&/g' \
            -e 's/Configuration/   Configuration/' \
            | sed 's/^ [^ ]/       &/'
        nl
    else
        echo -e "  --- Computer/CPU Information from '/proc/cpuinfo' --- "
        grep -m 1 -Ei 'model name' /proc/cpuinfo | sed 's/model name.*:.//g'
        nl
    fi
}

function FixNonAsciiVar() {
    # Call format to this function is: FixNonAsciiVar <var_name> <var_content>
    VarName=$1 # Local Var
    VarContent=$2 # Global Var

    # Check if field contains non ascii characters
    # Remember to set whatever the original passed variable equal to $VarContent after the call
    #     to catch the fixed return value.
    if [[ "$VarContent" == "*[!:ascii:]*" ]]
    then
        debug "$VarName contains Non-ASCII characters." 1
        debug "Content= $VarContent" 1
        # Remove non-ascii chars from string
        VarContent=$(sed 's/[\d0-\d8,\d11-\d31,\d127-\d255]//g' <<< $VarContent )
        debug "Fixed Content: $VarContent" 1
    fi
    unset $VarName
}

function GetDmi()
{
    # Checks for SMBIOS compliance and values for. Called once by GetMachineInfo().
    # Dynamically checks the dmi_var's and removes them from the array if not present
    #     to adjust for SMBIOS Standard Version variations.
    smbios_compliant="/sys/class/dmi/id/" # local var

    dmi_vars='bios_vendor
		bios_version
		bios_release
		board_vendor
		board_name
		board_version
		board_serial
		board_asset_tag' # local var

    echo -e "------------------ SMBIOS Information from '/sys/class/dmi/id/' "
    debug "SMBIOS Information" 1
    
    if [ -d $smbios_compliant ]
    then
        # Loop through once to verify all the vdi_var files exist first. If not, 
        #    then modify list by removing the file name from the declared array.
        dmi_idx=0 # local var for counter
        for dmi_var in ${dmi_vars}
        do
            if [ ! -f $smbios_compliant$dmi_var ]
            then
                debug "Deleting $dmi_var from array..." 1
                dmi_vars=( "${dmi_vars[@]/$dmi_var}" )
            fi
            dmi_idx+=1
        done
        
        # Then spin through the modified array to list them
        for dmi_var in ${dmi_vars}
        do
            dmi_content=$(sudo head -n 1 $smbios_compliant$dmi_var | \
                sed 's/[\d0-\d8,\d11-\d31,\d127-\d255]//g' )
            dmi_title=$(echo $dmi_var | sed -e 's/_/ /g' | sed -e 's/\b\(.\)/\u\1/g' ) 
                        
            if [ $dmi_var == "board_version" ]
            then               
                if [[ "$dmi_content" == "1234567890" ]]
                then
                    dmi_content=""
                fi
            elif [[ "$dmi_content" == *"default "* ]]
            then
                dmi_content="Value Not Set"
            fi
            printf "%-20s %s\n" "$dmi_title:" "$dmi_content";
        done
    else
        echo -e "No SMBIOS information found"
    fi
    nl
    printf "%-20s %s\n" "Current boot mode:" "$boot_mode"
    GetSb
    nl
    GetDmiDetails
    unset -v dmi_idx dmi_var dmi_vars dmi_content dmi_title
}

function GetDmiDetails()
{
    if [ $bios_detail -eq 0 ]
    then
        echo -e "Further details from BIOS:"
        sudo dmidecode -t 0,1,4
        nl
    fi
}

function GetSb()
{
    # Gets SafeBoot Info from UEFI BIOS or if not UEFI capable. Called once by GetDMI().
    # Warns user if mokutil was not present.
    echo -e "   --- SecureBoot Status from 'mokutil':"
    
    ## Bug found on some machines concerning the '--sb-state' option switch on 2022.06.01.
    #  Shortened to '--sb' (undocumented option switch) 
    # 'mokuitl' Bug was resolved within days...
    # 2022.06.02, Added fallack error handling for fallback to alternate option flag...
    # using the documented option flag as the primary method.
    if [ $check_mokutil -eq 0 ] 
    then
        echo -e "\tThis would check / have checked if SecureBoot was enabled or not, "
        echo -e "\tand checks if the system BIOS was UEFI or Legacy only BIOS, "
        echo -e "\tbut package mokutil was not installed. If you would like to check"
        echo -e "\tthis information, please install 'mokutil' and rerun script."
    else
        # Added this error handling because of a bug on a 'mokutil', that was resolved
        # but showed that an error was possible from a faulty update of this utility.
        error_mokutil=$(mokutil --sb-state 2>&1 )
        if [[  "$error_mokutil" == *"mokutil: unrecognized option '--sb-state​'"*  ]]
        then
            mokutil_cmd=$(mokutil --sb 2>&1 )
            error_mokutil=$mokutil_cmd
        else
            mokutil_cmd=$(mokutil --sb-state 2>&1 )
        fi
        # For Legacy only BIOS, returns error: "EFI variables are not supported on this system"
        if [[  "$error_mokutil" == *"EFI variables"*  ]]
        then
            echo -e "$error_mokutil"
        elif [[  "$error_mokutil" == *"Command 'mokutil' not found"*  ]] #
        then 
            echo -e "\tThis would check / have checked if SecureBoot was enabled or not, "
            echo -e "\t and checks if the system BIOS was UEFI or Legacy only BIOS, "
            echo -e "\tbut package mokutil was not installed. If you would like to check"
            echo -e "\tthis information, please install 'mokutil' and rerun script."                
        else
            sb_state=$mokutil_cmd
            debug "sb_state: $sb_state" 1
            if [[ $sb_state == "Failed to read SecureBoot" ]]
            then
                sb_disabled="SecureBoot: Disabled"
                #printf "%-20s %s\n" ${sb_disabled/ /: }
                echo -e "$sb_disabled"
            else
                # These are the known messages returned from mokutil
                # This system doesn't support Secure Boot
                # Secure Boot is enabled
                # Failed to read SecureBoot
                # Platform is in Setup Mode
                # mokutil: unrecognized option '--sb-state​'
                #
                #printf "%-20s %s\n" ${sb_state/ /: }
                echo -e "$sb_state"
            fi
        fi
        nl
    fi
    unset -v error_mokutil mokutil_cmd sb_state sb_disabled
}

function GetMem()
{
    # Gets memory information (physical and swap). Called once by GetMachineInfo().
    echo -e "${setansi}---------- Memory Information:$ransi"
    mem_stats=$(free -m)
    echo -e "$mem_stats"
    nl
    unset -v mem_stats
}

function GetSwap () {
    # Gets more swap information. Called once by GetMachineInfo().
    fstab_info=$(grep 'swap' /etc/fstab )
    swaps_info=$(awk '{print $0}' /proc/swaps )
    sw_proc=$(awk '{print $0}' /proc/sys/vm/swappiness )
    sw_sysctl=$(grep 'vm.swappiness' /etc/sysctl.conf )
    valid_settings="10 - 60"
    
    if [ "$sw_sysctl" == "" ]
    then
        sw_stsctl="If setting 'vm.swappiness' is not declared in '/etc/systctl', then the system inherits the default setting of '60'."
    fi
    
    echo -e "${setansi}---------- Swap Information:$ransi"
    echo -e "  --- Info from 'fstab'"
    echo -e "$fstab_info"
    nl
    echo -e "  --- Info from '/proc/swaps'"
    echo -e "$swaps_info"
    nl
    echo -e "  --- System Swappiness Settings"
    echo -e "Valid swappiness settings are from $valid_settings . "
    echo -e "Current setting in '/proc/sys/vm/swappiness': $sw_proc "
    echo -e "Current configuration setting in '/etc/sysctl.conf file: "
    echo -e "$sw_sysctl"
    nl
    unset -v fstab_info swaps_info sw_proc sw_sysctl valid_settings
}

function GetUsb()
{
    # Gets USB information. Called once by Writer().
    # Check condition added for IBM System 390.
    if [ -d /sys/bus/usb/devices ]
    then
        echo -e "${setansi}---------- USB Information from 'lsusb -t -v':$ransi"
        usb_info=$(lsusb -t $detail_level)
        echo -e "$usb_info"
    else
        echo "System does not have USB devices."
    fi
    nl
    unset -v usb_info 
}

function GetNetworkingInfo()
{
    # Gets Networking related Information. Called once by GetMachineInfo().
    GetIP
    CheckIpUp silent
    if [ "$up_status" == "true" ]
    then
        GetInternetStatus
    else
        echo -e "  --- Internet Connection Status from 'ip addr' --- "
        echo -e "Skipped getting Internet Status. Connection: $up_status"
        nl
    fi
    CheckIpUp show
    GetMoreWirelessInformation
}

function GetInternetStatus()
{
    # Verifies ping status and relsolv. Called once by GetNetworkingInfo().
    ping -c 1 www.google.com &> /dev/null
    pingStatus=$? # Global var
    echo -e "  --- Internet Connection Status from 'ping [various addresses]' --- "
    if [ $pingStatus == 0 ]
    then 
        echo -e "Connected to Internet with DNS"
    else 
        echo -e "Cannot reach internet by DNS"
        ping -c 1 8.8.8.8 &> /dev/null
        pingStatus=$?
        if [ $pingStatus == 0 ]
        then
            echo -e "Can reach the internet without DNS"
        else
            echo -e "Cannot reach internet by IP..."
        fi
    fi    
    nl
}

function GetPingStatus()
{
    # Takes arg as IP or URL. Returns pseudo boolean $return_status. Called twice (by Paster() and GetInternetStatus()).
    ping -c 1 $1 &> /dev/null
    pingStatus=$? # Global Var
    if [ $pingStatus == 0 ]
    then 
        return_status="true" # Global Var
    else 
        return_status="false" # Global Var
    fi    
    debug "GetPingStatus(): Value: $return_status" 1
}

function GetIP()
{
    # Get IP related information. Called once by GetNetworkingInfo().
    echo -e "${setansi}---------- IP Address Information:$ransi"
    echo -e "  --- IP Address Information from 'ip addr' --- "
    # Grab IP address information
    if [ "$less_status" == "less" ]
    then
        ip_addr=$(/sbin/ip addr | grep -e '^[[:space:][1-9]:' -e 'inet.') # Local Var
        echo -e "$ip_addr"
    else
        ip_addr=$(/sbin/ip addr | grep -e '^[[:space:][1-9]:' -e 'inet.' \
            | sed '/inet\s/ s/inet\s.*/inet [REMOVED]/g' \
            | sed '/inet6\s.*/ s/inet6\s.*/inet6 [REMOVED]/g') # Local Var
        echo -e "$ip_addr"
    fi
    unset -v ip_addr
    nl
}

function CheckIpUp()
{
    # Check to see if an exposed network device is up before going out to LAN. Called twice by GetNetworkingInfo()
    show_silent=$1        # show or silent. Eval is on: "show" # Global Var
    ip_devices_up=$(/sbin/ip addr | \
        grep -e '^[[:space:][1-9]:.*UP,LOWER_UP' | \
        sed 's/.*virb.*:.*\|.*lo:.*LOOPBACK.*//g' | \
        sed -e /^$/d) # Local Var
    if [ "$show_silent" == "show" ]
    then
        echo -e "  --- Network Device Status Summary from 'ip addr' ---  "
        if [ "$ip_devices_up" == "" ]
        then
            echo -e "No Network Devices up..."
            nl
            up_status="false"
        else
            echo -e "These Network Devices are up:"
            echo -e "$ip_devices_up"
            nl
            up_status="true"
        fi
    elif [ "$show_silent" == "silent" ]
    then
        if [ "$ip_devices_up" == "" ]
        then
            up_status="false"
        else
            up_status="true"
        fi
    else
        debug "'show_silent' call out of range $show_silent" 1
    fi
    debug "show_silent: $show_silent 'up_status': $up_status" 1
    unset -v ip_devices_up
}

function GetHostname()
{
    # Gets Hostname information. Called once by GetMachineInfo().
    #     Values for $check_hostname:
    #         0 = Use 'hostname'
    #         1 = Use 'hostnamectl'
    #         2 = 'hostname' and 'hostnamectl' were not found.
    #                 Print alternate message.
    if [ $check_hostname -eq 0 ]
    then
        hostname_long=$(hostname --fqdn)  # Local Var
        hostname_short=$(hostname | \
            sed 's/\..*//g')  # Local Var
        hostname_title="'hostname --fqdn'"  # Local Var
    elif [ $check_hostname -eq 1 ]
    then
        hostname_long=$(hostnamectl --static )
        hostname_short=$(hostnamectl --static | \
            sed 's/\..*//g')
        hostname_title="'hostnamectl --static'"
    else
        hostname_long="<Could not be determined>"
        hostname_short="<Could not be determined>"
        hostname_title="'hostname'"
    fi
    
    echo -e "  --- Hostname from $hostname_title ---  "
    if [ "$less_status" == "less" ]
    then
        host_name=$hostname_long
    else
        host_name=$hostname_short
    fi
    echo -e "The 'Hostname' of the computer system is: $host_name"
    nl
    unset -v hostname_long hostname_short hostname_title host_name
}

function GetDiskInfo()
{
    # Gets filesystem, disk, fstab and mount information. Called once by Writer().
    GetStorageControllers
    echo -e "${setansi}---------- File system specs from 'df -h':$ransi"
    df -hT -x tmpfs -x devtmpfs | grep -v '/snap/'
    nl
    echo -e "${setansi}---------- Disk/Partition Information From 'fdisk':$ransi"
    sudo fdisk -l 2>&1 | sed '/\/dev\/loop/,+3 d' 2> /dev/null | uniq
    nl
    echo -e "${setansi}---------- Disk/Partition Information From 'lsblk':$ransi"
    # Note: sed replacement added to switch out non-ascii characters of 'lsblk'. 
    #     'paste.ubuntu.com' does not accept non-ascii characters
    lsblk -o NAME,SIZE,FSTYPE,LABEL,MOUNTPOINT,MODEL | grep -v '/snap/' | sed 's/^[\|,`]-/\|_/g'
    echo -e "   ------- 'lsblk' information continued ..."
    lsblk -o NAME,HOTPLUG,PARTUUID,UUID | grep -v 'loop' | sed 's/^[\|,`]-/\|_/g'
    nl
    GetZfsInfo
    GetLuksInfo
    GetBtrfs
    GetLvm2
    GetMdDevices
    echo -e "${setansi}---------- Mount Details of '/etc/fstab':$ransi"
    grep -E -v '#' /etc/fstab
    nl
    GetMountInfo
    GetMoreDiskInfo
}

function GetMoreDiskInfo() {
    echo -e "For more detailed disk Information, please run the 'boot-info' script "
    echo -e "from: (STABLE) https://launchpad.net/~yannubuntu/+archive/ubuntu/boot-repair "
    nl
}

function GetMoreAlsaInformation() {
    echo -e "For more detailed audio information, get and run the script at: http://www.alsa-project.org/alsa-info.sh "
    nl
}

function GetMoreWirelessInformation() {
    echo -e "For more detailed wireless information, get and run the script at https://github.com/UbuntuForums/wireless-info "
    nl
}

GetMountInfo()
{
    mount_info=$(mount | grep '^/dev' | sort) # local var
    
    if [ "$mount_info" == "" ]
    then
        mount_info=$(mount)
    fi
    echo -e "${setansi}---------- Current Mount Details of 'mount':$ransi"
    echo -e "$mount_info"
    nl
    unset -v mount_info
}

function GetZfsInfo()
{
    zfs_part_type=$(sudo fdisk -l 2>&1 | \
        sed '/\/dev\/loop/,+3 d' 2> /dev/null | \
        uniq | grep -m 1 'Solaris\|FreeBSD' ) # Local Var
    zfs_fs_type=$(df -hT -x tmpfs -x devtmpfs | \
        grep -v '/snap/' | \
        grep -m 1 'zfs') # Local Var # value Type='zfs' would be in field $2
    
    if [[ "$zfs_part_type" != "" ]]
    then
        echo -e "${setansi}----------  ZFS Information:$ransi"
        echo -e "System has at least one ZFS type partition."
        nl
        if [[ "$zfs_fs_type" != "" ]]
        then
            echo -e "System has ZFS rpools activated."
            nl
            if [ $zfs_detail -eq 0 ]
            then
                # Shown only if --details or -d option is used 
                sudo zfs list
                nl
                sudo zpool list
                nl
                sudo zpool status -v
                nl
                sudo zpool iostat
                nl
                GetZfsProperties
            else 
                echo -e "If you restart the script adding a '-d' startup option, it will show more details."
                nl
            fi
        else
            echo -e "System has no ZFS rpools activated."
        fi
        nl
    fi
    unset -v zfs_part_type zfs_fs_type
}

function GetZfsProperties()
{
    # Get a list of all Pool Names
    PdList=$(sudo zpool list | awk '{print $1}' | grep -v 'NAME' )

    for PoolDatasetName in ${PdList}
    do
        # Get the 'pool/dataset' upper field from the pool name
        PoolDataset=$(sudo zfs list -r $PoolDatasetName | grep -v 'NAME' | head -n2 | tail -1 | awk '{print $1}' )
        echo -e "---- $PoolDataset Properties"
        echo ""
    
        # Get Pool level property values
        for value1 in ashift capacity fragmentation health
        do
            sudo zpool get $value1 $PoolDatasetName | grep -v 'NAME'
        done
    
        # Get Dataset level property values
        for value2 in sync recordsize compression compressratio atime xattr logbias dedup acltype copies volblocksize
        do 
            sudo zfs get $value2 $PoolDataset | grep -v 'NAME'
        done
        echo ""
    done
}

function GetLuksInfo()
{
    luks_fs_type=$(lsblk -o NAME,FSTYPE | \
        grep -m 1 'crypto_LUKS' )
    if [[ "$luks_fs_type" != "" ]]
    then
        echo -e "${setansi}----------  LUKS Information:$ransi"
        echo -e "System has a LUKS encrypted filesystem."
        nl
    fi
    unset -v luks_fs_type
}

function GetMdDevices()
{
    echo -e "${setansi}----------  mdadm RAID Information:$ransi"
    # Test for md devices
    md_devs=$(ls /sys/class/block/md*/md/* 2> /dev/null)

    if [ ! -z "$md_devs" ]
    then 
        echo -e "mdadm RAID device present."
        nl
        grep 'raid\|level' /proc/mdstat | grep -v 'Personalities'
        nl
        md_detail=0
    else
        echo -e "No active md devices present."
        MdFile=$(grep '\/dev\/md\/' /etc/mdadm/mdadm.conf 2> /dev/null )
        if [ ! -z "$MdFile" ]
        then 
            nl
            echo -e "Inactive md devices from /etc/mdadm/mdadm.conf file: "
            echo -e "$MdFile"
            nl
        fi
    fi
    #nl
    
    GetMdInfo
}

function GetMdInfo()
{
    if [ $md_detail -eq 0 ]
    then 
        sudo mdadm -D /dev/md* 2> /dev/null
        nl
        grep '\/dev\/md\/' /etc/mdadm/mdadm.conf 2> /dev/null
        nl
    fi
}

function GetBtrfs()
{
    echo -e "${setansi}----------  BTRFS Information:$ransi"
    # Show BTRFS dev's and their mounts
    bt_lsblk=$(sudo lsblk -o name,mountpoint,size,fstype,UUID | \
        grep 'btrfs' | \
        awk '{print $1 "  " $2}' | \
        sed 's/var.*//g' | \
        sed 's/^[\|,`]-/\|_/g' )
        
    # echo "Debug -- bt_lsblk: $bt_lsblk"

    if [ -z "$bt_lsblk" ]
    then 
        echo -e "There are no BTRFS vdev's present."
        nl
    else
        echo -e "There are BTRFS vdev's present: "
        nl
        echo -e "BT_VDEV    MOUNT "
        echo -e "$bt_lsblk"
        nl
        btrfs_detail=0 # Set flag for BTRFS present
        GetBtrfsInfo
    fi
}

function GetBtrfsInfo()
{
    if [ $btrfs_detail -eq 0 ]
    then
        sudo btrfs filesystem show
        nl

        # Get for BTRFS volume names
        btdev_vols=$(mount | \
            grep -v 'snap' | \
            grep 'btrfs' | \
            awk '{print $3}' )
            
        for vol in ${btdev_vols}
        do
            echo "Properties of BTRFS Volume: $vol"
            sudo btrfs property get $vol
            nl
        done
            
        # echo "Debug -- btdev_vols :"
        # echo "$btdev_vols" # DEBUG

        for vol in ${btdev_vols[@]}
        do
            # echo "Debug -- vol: $vol"
            
            FsName=$()
            
            SubVolName=$(sudo btrfs subvol list $vol | \
                awk '{print $9} ' )
    
            # echo "Debug -- SubVolName: $SubVolName"
            
            if [ -z "$SubVolName" ]
            then
                echo -e "BTRFS filesystem present on $vol, but no BTRFS SubVolumes there."
                nl
            else
                sudo btrfs subvol show -h $vol
                nl
            fi
        done
    fi
}

function GetLvm2()
{
    echo -e "${setansi}----------  LVM2 Information:$ransi"
    # ID LVM filesystem
    lvm_vdev=$(sudo lsblk -o name,mountpoint,fstype | \
        grep 'LVM' | \
        cut -b 7- | \
        sed 's/^/\/dev\//g' )
    mapper_vdev=$(ls /dev/mapper/ | \
        grep -v 'control' )

    if [ ! -z "$lvm_vdev" ] && [ ! -z "$mapper_vdev" ]
    then
        echo -e "LVM2 is installed."
        nl
        lvm2_detail=0
        GetLvm2Info
    else
        echo -e "There are no LVM2 volumes present."
        nl
    fi
    #nl
}
    
function GetLvm2Info()
{    
    if [ $lvm2_detail -eq 0 ]
    then
        sudo pvs -v
        nl
        sudo pvscan -v
        nl
        sudo pvdisplay -v -m
        nl
        sudo vgs -v
        nl
        sudo vgscan -v
        nl
        sudo vgdisplay -v
        nl
        sudo lvs -a -o name,segtype,devices
        nl
        sudo lvscan -v
        nl
        sudo lvdisplay -v
        nl
fi
}

function GetStorageControllers() {
    # Based on this information: 
    #     lspci | grep --color=never -i -e 'IDE controller' -e 'SATA controller' -e 'SCSI controller' -e 'Non-Volatile memory controller' -e 'RAID Controller'
    echo -e "${setansi}---------- Storage Controller Information From 'lspci':$ransi"
    cntrllr_busid_list=$(sudo -i lspci | \
        grep --color=never -i -e 'IDE ' \
            -e 'SATA ' \
            -e 'SCSI ' \
            -e 'Non-Volatile memory ' \
            -e 'RAID ' | \
        awk '{print $1}') # Local Var
    # Modified for devices which have no formal storage controllers besides USB or SD
    if [ ! -z "$cntrllr_busid_list" ]
    then
        # Parse through list (array) and show detailed information on each
        for controller in ${cntrllr_busid_list}
        do
            sudo -i lspci -s $controller $detail_level
            nl
        done
    else
        echo -e "No storage controller found. Check in 'lsusb' section."
        echo -e "May be USB or SD storage."
        nl
    fi
    unset -v controller cntrllr_busid_list
}

function GetGraphicsEnv() 
{
    # Gets Graphics Layer Information. Called once by Writer().
    # Do not call $lshw_cmd if lshw is not installed...
    if [[ "$check_lshw" == "0" ]] && [[ "$detail_level" == "-v" ]]
    then
        if [[ "$detail_level" == "-v" ]]
        then
            lspci_detail="-nnk"
        fi
        echo -e "${setansi}---------- Video Details from 'lshw':$ransi"
        nl
        #lshw_data=$(sudo lshw -C video )
        lshw_data=$(sudo lshw -C video \
            | sed -e 's/ *resources/resources/' \
            -e '/resources/ s/ [^ ]*:[^ ]*/ \n&/g' \
            -e 's/resources:/       resources:/g' \
            | sed 's/^ [^ ]/          &/' )
    
        if [ "$lshw_data" == "" ]
        then
           echo -e "No conventional GPU detected. May be using a Frame Buffer."
        else
            echo -e "$lshw_data"
        fi
        nl
    else
        # Use alternate method to display GPU info
        echo -e "${setansi}---------- Video Details from 'lspci':$ransi"
        #lspci | grep -i 'VGA\|Display\|3D' | sed 's/[0-9][0-9]:[0-9][0-9]\.[0-9] //g'
        gpu_list=$(sudo -i lspci | \
            grep --color=never -i -e 'VGA' | \
            awk '{print $1}')
        # Modified for devices which have no formal GPU's
        if [ ! -z "$gpu_list" ]
        then
            # Parse through list )array) and show detailed information on each
            for gpu in ${gpu_list}
            do
                sudo -i lspci -s $gpu $lspci_detail
                nl
            done
        else
            echo -e "No formal GPU found. Check in other places for a framebuffer."
            nl
        fi
        unset -v gpu_list
    fi
    echo -e "   --- Graphics Environment Continued from 'various graphics ENVs' ----" 
    if [ "$XDG_CURRENT_DESKTOP" != "" ] 
    then 
        echo -e "The Current Configured Desktop is: $XDG_CURRENT_DESKTOP " 
    else
        echo -e "The Current Configured Desktop is: <Not Populated> " 
    fi
    if [ "$DESKTOP_SESSION" != "" ]
    then
        echo -e "The Current Desktop Session is: $DESKTOP_SESSION "
        if [[ "$detail_level" == "-v" ]]
        then
            xmode=$(xrandr -q 2> /dev/null | \
                grep -E --color=never -e 'Screen' -e 'connected ')
        else
            xmode=$(xrandr -q 2> /dev/null )
        fi
        echo -e "The Current X Desktop Information Details from 'xrandr' are: "
        echo -e "$xmode" 
    else
        echo -e "The Current Desktop Session is: <Not Populated> " 
    fi
    unset -v xmode
    
    if [ "$XDG_SESSION_TYPE" != "" ]
    then
        echo -e "The Current Session Type is: $XDG_SESSION_TYPE " 
    else
        session_type=$(ps -e | \
            grep -E -e 'tty' | \
            grep -E -e 'x11|Xorg|wayland' | \
            awk '{print $4}')
        if [ "$session_type" != "" ]
        then
            echo -e "The Current Session Type is: $session_type " 
        else
            echo -e "The Current Session Type is: <No Graphics Session Type Loaded> " 
        fi
    fi
    unset -v session_type
    
    if [ -f /etc/X11/default-display-manager ]
    then
        display_manager=$(grep -E -e '/usr/sbin/' /etc/X11/default-display-manager | \
            sed 's/\/usr\/sbin\///g')
        echo "The Current Display Manager is: $display_manager" 
    else
        echo "The Current Display Manager is: <Not Configured>" 
    fi
    unset -v display_manager
    
    # This change is to adapt to Server Edition, which for some reason, can have a gsettings setting.
    get_console_desktop=$([ -d /usr/share/xsessions/ ] && \
        echo "Desktop" || \
        echo "Console") # Local Var
    if [ "$get_console_desktop" == "Desktop" ]
    then
        desktop_theme=$(gsettings get org.gnome.desktop.interface gtk-theme) # Local Var
        if [ "$desktop_theme" != "" ]
        then
            echo -e "The Current Desktop Theme: $desktop_theme" 
        else
            echo -e "The Current Desktop Theme: <None Configured>" 
        fi 
    else
        echo -e "The Current Desktop Theme: Is not set, this is Console Based." 
    fi
    unset -v get_console_desktop desktop_theme
    
    virt_ttys=$(ps -e | \
        awk '$2 ~ /^tty/ || $2 ~ /^ttyS/ || $2 ~ /^pts/ {print "\t" $2 "\t" $4}') # Local Var
    echo -e "The Current Virtual TTY's being used are:" 
    echo -e "\tTTY#\tUsed By" 
    echo -e "$virt_ttys" 
    unset -v virt_ttys
    nl
}

function GetSoundDevices() {
    # Retrieve Sound device ID's 
    echo -e "${setansi}---------- Sound Device Information From 'lspci':$ransi"
    sound_device_list=$(sudo -i lspci | \
        grep --color=never -i -e 'audio ' | \
        awk '{print $1}') # Local Var
    # Make sure not NULL
    if [ ! -z "$sound_device_list" ]
    then
        # Parse through list (array) and show detailed information on each
        for sound_device in ${sound_device_list}
        do
            sudo -i lspci -s $sound_device $detail_level
            nl
        done
    else
        echo -e "No sound devices found. Also check in 'lsusb' section."
        nl
    fi
    if [[ "$detail_level" == "-vv" ]]
    then
        # Only displays in detailed mode
        echo -e "   --- More Sound Device info from 'aplay' ----"         
        aplay --list-devices --list-pcms
        nl
    fi
    GetMoreAlsaInformation

    unset -v sound_device sound_device_list
}

function GetKeyMap() {
    echo -e "${setansi}---------- KeyMap and Locale Information from from various sources:$ransi"

    # setxkbmap & xset are part of package 'x11-xserver-utils', not installed if no xserver present.
    # In Ubuntu: /etc/default/... cfg are keyboard and locale files
    get_console_desktop=$([ -d /usr/share/xsessions/ ] && \
        echo "Desktop" || \
        echo "Console") # Local Var
    if [ "$get_console_desktop" == "Desktop" ]
    then
        echo -e "   --- Keymap Info from 'setxkbmap' ----"  
        setxkbmap -query  2> /dev/null
        nl
        if [[ "$detail_level" == "-vv" ]]   
        then  
            echo -e "   --- More Keymap Info from 'xset' ----"  
            xset -q 2> /dev/null
            nl
            echo -e "   --- More Keymap Info from 'gsettings' ----" 
            input_sources=$(gsettings get org.gnome.desktop.input-sources sources 2> /dev/null ) 
            echo -e "gsettings input-sources:  $input_sources "
            nl
        fi
    else
        echo -e "   --- Keymap Info from 'setxkbmap' ----"
        if [ -f /etc/default/keyboard ] 
        then 
            awk '{print $0}' /etc/default/keyboard
            nl
        else
            echo -e "This is console-only and not Debian Branch."
            nl
        fi
    fi
          
    echo -e "   --- Locale Info from 'localectl' ----"  
    echo -e "$localectl_status"
    nl 
    if [[ "$detail_level" == "-vv" ]]   
    then  
        echo -e "   --- More Locale Info from 'locale' ----"  
        echo -e "$locale_state"
        nl
    fi
    unset -v get_console_desktop input_sources
}

function GetRepositories()
{
    # Gets Repository Information. Called once by Writer().
    # 	Method only works in Debian Branch. Check for Debian Branch first...
    debug "debian_branch: $debian_branch" 1
    if [[ "$debian_branch" == "0" ]]
    then    
        echo -e "${setansi}---------- Repository Information from '/etc/apt/sources.list and etc/apt/sources.list.d/':$ransi"
        nl
        sources=$(grep -v '#' /etc/apt/sources.list | sed -e /^$/d ) # Local Var
        # sourcesd=$(grep -v '#' /etc/apt/sources.list.d/* | sed -e /^$/d)
        echo -e "Sources List:"
        echo -e "$sources"
        nl
        sourcesd_file_path="/etc/apt/sources.list.d/" # Local Var
        if [ $(find $file_path -type f 2> /dev/null | wc -l) -ne 0 ] 
        then  
            echo -e "Sources List from SourcesD:"
            sourcesd_files=$(find $sourcesd_file_path -type f 2> /dev/null ) # Local Var
            for list_file in $sourcesd_files
            do
                lines=$(grep -v '#' $list_file | \
                    sed -e /^$/d ) 
                #line_count=$( wc -l <<< "$lines" )
                if [ "$lines" != "" ]
                then
                    echo -e "$list_file:"
                    echo -e "$lines"
                else
                    echo -e "$list_file:"
                    echo -e "File had no entries."
                fi
           done
           nl
        fi
    else
        echo -e "${setansi}---------- Repository Information"
        echo -e "The repository method written in this script is only for Debian Branch."
        echo -e "This system is not derived from a Debian Branch"
        nl
    fi
    unset -v sources sourcesd_file_path sourcesd_files list_file lines
}

function GetOtherDetails()
{
    # Gets Other General Details. Gets called once by Writer().
    echo -e "${setansi}---------- Other Details from 'Various':$ransi"
    echo -e "The current kernel version is:      ${setansi} $(uname -r) $ransi"
    GetReleaseDescription
    GetOriginalInstallDate
    GetInstallMedia
    GetDistUpgradeDate
    GetHweInfo
    GetUserInstalled
    GetSnapInstalled
    GetFlatpakInstalled
    GetUser
    GetLive
    GetWhere
    GetCmdLine
}

function GetOriginalInstallDate()
{
    # Gets the original installation date. Called once by GetOtherDetails().
    # Makes best logical efforts.
    if [ $(sudo find /var/log/installer/ -type f 2> /dev/null | wc -l) -ne 0  ]
    then
        installer_date=$(sudo find /var/log/installer/ -type f -printf "%T+\n" 2> /dev/null | \
            sort| \
            head -1 2> /dev/null ) # Local Var
        installer_date="Original Installation Date:         ${setansi} ${installer_date%.*} $ransi"
    else
        debug "Installer date: $(sudo find / -maxdepth 1 -type d -printf "%T+ %p\n" > /dev/null | sort| head -1 )" 1 
        #installer_date=$(sudo find / -maxdepth 1 -type d -printf "%T+ %p\n" 2> /dev/null | sort | head -1)
        installer_date=$( \
            for i in /*; \
            do \
                if ! mountpoint -q "$i"; \
                then \
                    stat --format='%y %n' "$i"; \
                else \
                    echo -e 'Could not accurately determine original Installation Date.'
                fi; \
            done \
            | sort \
            | head -1 \
            | sed 's/ .*//' )
        #installer_date=$(sudo find / -maxdepth 1 -type d -printf "%T+ %p\n" 2> /dev/null | sort | head -1)
        installer_date="Estimated Installation Date:        ${setansi} ${installer_date%.*} $ransi"
    fi
    echo -e "$installer_date"
    unset -v installer_date
}

function GetInstallMedia()
{
    # Gets the original install media data. Called once by GetOtherDetails().
    # Only displays if it was installed traditionally
    if [ -d /var/log/installer/ ]
    then
        # Check to See if the media-info file was created before trying to read it...
        # On some pre-created Ubuntu Image Files now available, the /var/log/installer directory exists
        # but the files within that directory have been removed before release for distribution.
        if [ -f /var/log/installer/media-info ]
        then
            installer_media=$(sudo head -n 1 /var/log/installer/media-info | \
                awk '{print "Original Installation Media: "$0}' ) # Local Var
            echo -e "$installer_media"
        elif [ -f /var/anaconda/journal.log ]
        then
            # RHEL Branch
            installer_media=$(grep -i 'CDLABEL' | head -n 1 | awk '{print $10}' | sed 's/root=live:CDLABEL=//g' )
            echo -e "$installer_media"
        elif [ -f /var/anaconda/journal.log ]
        then
            # SUSE Branch
            installer_media=$(sudo grep 'alias' /var/log/zypper.log | grep 'SUSE' | head -n 1 | awk '{print $10}' )
            echo -e "$installer_media"
        else
            echo -e "The Installer log directory exists, but the Installer log files have been removed."
            echo -e "This system may have been installed from a distribution  image file."
        fi
    else
        echo -e "Original Installation Media: Cannot determine which ISO this was installed from (yet). "
        echo -e "The Installer Log Directory does not exist. "
    fi
    unset -v installer_media
}

function GetDistUpgradeDate()
{
    # Gets Do_Release_Update date. Called once by GetOtherDetails().
    # Displays if it ever had a do-release-upgrade process done
    if [ -f /var/log/dist-upgrade/apt.log ]
    then
        drg_date=$(sudo grep -E -m 1 -e 'Log Time' /var/log/dist-upgrade/apt.log | \
            awk '{"Do-Release-Upgrade Date: "$3 }' ) # Local Var
        echo -e "$drg_date"
    else
        echo -e "Do-Release-Upgrade Date: This system may have not had a 'Release Upgrade' through 'do-release-upgrade'"
    fi
    nl
    unset -v drg_date
}

function GetHweInfo()
{
    # Get HWE information safely. Only call if it is a flavor of Ubuntu
    # Check if in Debian Branch
    echo -e "   --- Hardware Enablement Stack (HWE) Informationt:"
    if [[ "$debian_branch" == "0" ]]
    then
        # Make sure it is a flavor of Ubuntu
        if [[ "$ubuntu_flavor" == "0" ]]
        then
            GetHweRange
            if [ ! -z "$LTS_PKG" ]
            then
                GetHweKernels
                CheckHwe
                CheckIfCertifiedHardwarePlatform
            fi
        else
            echo -e "System tested is Debian Branch, but is not an Ubuntu or an Ubuntu flavor."
            echo -e "HWE is Ubuntu specific."
            nl
        fi
    else
        echo -e "System tested is either not Ubuntu or is an Ubuntu EOS release version."
        echo -e "HWE is Ubuntu specific."
        nl
    fi

}

function GetHweRange() {
    # Valid current choices for Release numbers LTS are: 14.04 through current DEV versions...
    LSB_Rel=$(lsb_release -sr | \
        cut -c 1-5) # Local Var
    case "$LSB_Rel" in
        ("14.04")
            LTS_PKG="14.04"
            ;;
        ("14.10")
            LTS_PKG="14.04"
            ;;
        ("15.04")
            LTS_PKG="14.04"
            ;;
        ("15.10")
            LTS_PKG="14.04"
            ;;
        ("16.04")
            LTS_PKG="16.04"
            ;;
        ("16.10")
            LTS_PKG="16.04"
            ;;
        ("17.04")
            LTS_PKG="16.04"
            ;;
        ("17.10")
            LTS_PKG="16.04"
            ;;
        ("18.04")
            LTS_PKG="18.04"
            ;;
        ("18.10")
            LTS_PKG="18.04"
            ;;
        ("19.04")
            LTS_PKG="18.04"
            ;;
        ("19.10")
            LTS_PKG="18.04"
            ;;
        ("20.04")
            LTS_PKG="20.04"
            ;;
        ("20.10")
            LTS_PKG="20.04"
            ;;
        ("21.04")
            LTS_PKG="20.04"
            ;;
        ("21.10")
            LTS_PKG="20.04"
            ;;
        ("22.04")
            LTS_PKG="22.04"
            ;;
        ("22.10")
            LTS_PKG="22.04"
            ;;
        ("23.04")
            LTS_PKG="22.04"
            ;;
        ("23.10")
            LTS_PKG="22.04"
            ;;
        ("24.04")
            LTS_PKG="24.04"
            ;;
        (*)
            echo -e "Something went wrong. LTS Edition out of HWE support range."
    esac    
    # LTS_PKG is Global Var
    debug "HWE LTS_PKG: $LTS_PKG" 1
    unset -v LSB_Rel
}

function GetHweKernels()
{
    echo -e "These are the current kernel ranges for HWE kernels for this release."

    show_kernels=$(apt-cache show linux-generic-hwe-$LTS_PKG 2> /dev/null \
        | awk '/Depends:/ {print "For HWE Package: " $2 ", Kernel Version: " $4}' \
        | sed -e 's/..$//' -e 's/~.*//') 2> /dev/null # Local Var
    echo -e "   --- HWE Kernel Reference from 'apt-cache show':"
    echo -e "$show_kernels"
    nl
    unset -v show_kernels
}

function CheckHwe()
{
    return_status=$(dpkg -s linux-generic-hwe-$LTS_PKG 2>&1 \
        | grep 'Status\|dpkg-query' ) # Local Var
    echo -e "   --- HWE Package Status from 'dpkg':"
        if [[ "$return_status" == *"Status:"* ]]
        then 
            echo -e "Package linux-generic-hwe-$LTS_PKG is installed."
        elif [[ "$return_status" == *"is not installed"* ]]
        then
            echo -e "HWE package linux-generic-hwe-$LTS_PKG was not detected. Please check "
            echo -e "kernel version to verify range"
        fi
        nl
        unset -v return_status
}

function CheckIfCertifiedHardwarePlatform()
{
    platform_check=$(ubuntu-drivers list-oem 2> /dev/null ) # Local Var
    echo -e "   --- Certified Hardware Platform Status: (By the Ubuntu Wiki Standards)"
    if [ -z $platform_check ]
    then
        echo -e "Ubuntu Certified Hardware Platform. Safe to install "
        echo -e "the Hardware Enablement Stack (HWE)."
    else
        echo -e "Hardware meta packages were listed. Please refrain from manually changing "
        echo -e "the kernel flavors. The Hardware Enablement Stack (HWE) should not be "
        echo -e "installed on this platform. "
    fi
    nl
    unset -v platform_check
}

function GetUserInstalled()
{
    ## Get a list of User Installed Packages 
    # This only works for Debian Branch...
        
    echo -e "   --- User Installed Package List:"
    # check if Debian Branch. Otherwise 'apt-mark' will not be found...
    if [[ "$debian_branch" == "0" ]]
    then    
        manually_installed=$(mktemp /tmp/ManuallyInstalled-XXXXX)
        default_installed=$(mktemp /tmp/DefaultInstalled-XXXXX)
        user_installed=$(mktemp /tmp/UserInstalled-XXXXX)
        # Use apt-mark to list all packages marked as manually installed. 
        apt-mark showmanual | sort -u > $manually_installed
        # Check to see if default installed list exists
        # for prebuilt system images, it does not exist
        if [ -f /var/log/installer/initial-status.gz ]
        then 
            # Get the list of default installed packages at initial installation.
            gzip -dc /var/log/installer/initial-status.gz 2> /dev/null | \
                sed -n 's/^Package: //p' | \
                sort -u > $default_installed
        else 
            touch $default_installed
        fi
        # Use compare, to exclude those defaults that are unique, AND exclude defaults 
        # that are presently marked as manually installed. (Those 'may' have been changed.)  
        comm -23 $manually_installed $default_installed > $user_installed
        # Print the list in two columns
        awk 'NF' $user_installed #\ Removed 2022.03.10 to turn to one column
        #| pr -2T  # You can remove the pr filter on this to keep output in a single column...
        nl # Add newline in report
        # Remove the temporary files
        rm -f $manually_installed
        rm -f $default_installed
        rm -f $user_installed
    else
        echo -e "The system tested is not in the Debian Branch. "
        echo -e "The method written in this script is for Debian Branch conventions."
        nl
    fi
    unset -v manually_installed default_installed user_installed
}

function GetSnapInstalled()
{
    ## Get a list of Installed Snap Packages
    echo -e "   --- Installed Snap Package List:"
    snap_list=""  # Local Var
    snap_list=$(snap list 2>&1)
    snap_exit=$?  # Local Var
    if [[ "$snap_exit" == "0" ]]
    then       
        snap_list=$(snap list | \
            awk '{print $1}' | \
            grep -v 'Name')
        snap_count=0  # Local Var
        
        if [ "$snap_list" == "" ] 
        then
            echo -e "No Snap Packages Installed"
        else
            for snap_package in "${snap_list[@]}"
            do 
                echo "$snap_package"
                ((snap_count++))
            done
            debug "Snaplist count: $snap_count" 1
        fi
    else
        echo -e "Snap is not installed"
    fi
    unset -v snap_list snap_exit snap_count snap_package
    nl
}

function GetFlatpakInstalled()
{
    ## Get a list of Installed Flatpak Packages
    echo -e "   --- Installed Flatpak Package List:"
    flatpak_list=""  # Local Var
    flatpak_list=$(flatpak list 2>&1)
    flatpak_exit=$?  # Local Var
    if [[ "$flatpak_exit" == "0" ]]
    then       
        flatpak_list=$(flatpak list | \
            awk '{print $1}' | \
            grep -v 'Name')  # Local Var
        debug "Flatpak list count:${#flatpak_list[@]}" 1
        
        if [ "$flatpak_list" == "" ] 
        then
            echo -e "No Flatpak Packages Installed"
        else
            for flatpak_package in "${flatpak_list}"
            do 
                echo "$flatpak_package"
            done
        fi
    else
        echo -e "Flatpak is not installed"
    fi
    unset -v flatpak_list flatpak_exit flatpak_package
    nl
}

function GetLive 
{
    debug "GetLive: (Debug)" 1
    live=false  # Local Var
    live_test1=$(mount | \
        grep ' / ' | \
        grep -o -e squashfs \
            -e tmpfs \
            -e aufs )  # Local Var
    live_test2=$(df | \
        grep ' /$'| \
        grep -o -e overlay \
            -e cow \
            -e aufs \
            -e rootfs \
            -e /dev/mapper/live-rw \
            -e union )  # Local Var

    if [ "$live_test1" != "" ]
    then
        live=true
    elif [ "$live_test2" != "" ]
    then
        live=true
    fi

    if $live
    then
        live_installed="a Live Image Environment (LIE)."  # Local Var
    else
        live_installed="an installed system"
    fi
    echo -e "The 'system-info' script was booted from $live_installed"
    debug "Live Installed: $live_installed" 1
    unset -v live live_test1 live_test2
    nl
}

function GetWhere()
{
    if [ -e /usr/bin/pstree ]
    then 
        if pstree -A -p -l -s &> /dev/null
        then 
            LocalOrSsh
        else
            GetLocal
        fi
    else
        GetLocal
    fi
}

function LocalOrSsh()
{
    debug "LocalOrSsh:" 1
    message_tmpstr="locally"
    pidsi="$$"
    debug "pidsi=$pidsi" 1
    treestr=$(pstree -A -p -l -s $pidsi)
    debug "$treestr" 1
    debug "" 1
    debug "-------- ^ whole treestr ^ -------- v trimmed treestr v --------" 1
    treetrm=$(echo $treestr | \
        sed -e "s/.*sshd/sshd/" | \
        sed -e "s/($pidsi).*/($pidsi)/")
    debug "$treetrm" 1
    treestr_test=$(echo "$treestr" | \
        grep 'sshd')
    debug "$treestr_test" 1
    if [[ "$treestr_test" != "" ]]
    then
        message_tmpstr="via ssh"
     fi

     debug "$message_tmpstr" 1
     echo "The 'system-info' script seems to be running $message_tmpstr"
     nl
     unset -v message_tmpstr pidsi treestr treetrm treestr_test
}

function GetLocal 
{
    debug "GetLocal: (Debug)" 1
    
    local_status="locally."  # Local Var
    # Get pts session of where the script was run       
    pts=$(echo $(ps -C "${0##*/}") | \
        awk '{print $6}')  # Local Var

    if [ "$pts" != "" ] 
    then
        # Get pts session of the current user if they are
        #     using a sshd session
        ssh_test=$(ps -ef | \
           grep "@$pts" | \
           grep "sshd" | \
           awk '{print$9}' | \
           sed 's/.*@//g' \
           2> /dev/null)  # Local Var
        ssh_user=$(ps -ef | \
           grep "$USER@$pts" | \
           grep "sshd" | \
           awk '{print$9}' | \
           sed 's/@,*//g' \
           2> /dev/null)  # Local Var
        # Compare the pts sessions
        if [ "$pts" == "$ssh_test" ]
        then
            local_status="via ssh."
        fi
    fi
    debug "PTS: $pts" 1
    debug "ssh_test: $ssh_test" 1
    debug "ssh_user: $ssh_user" 1
    debug "Current User: $USER" 1
    echo "The 'sysetm-info' script seems to be running $local_status "
    unset -v local_status pts ssh_test ssh_user
    nl
}

function GetUser() {
    echo -e "Currently logged in User(s):"
    who -H
    nl
    echo -en "The User running this script was: "
    id -un
    id | \
        tr ' ' '\n'| \
        sed 's/,/, /g'| \
        fold -sw 80 | \
        sed 's/ //g'
    nl
}

function GetCmdLine() {
    cmd_line=$(awk '{print $0}' /proc/cmdline)
    echo -e "The Linux Kernel Command Line use to boot was: "
    echo -e "$cmd_line"
    nl
}

function AdjustForLessStatus()
{
    # Sets Env Vars for less viewer or not (written report). Called once by Writer()
    if [ "$less_status" == "less" ]
    then
        setansi="$blueback"  # Global Var
        ransi="$resetvid"  # Global Var
        lshw_cmd='sudo lshw'  # Global Var
        MessageView
        MessageLess
    else
        setansi=""
        ransi=""
        lshw_cmd='sudo lshw -sanitize'
    fi
}

function ReportHeader()
{
    # Start of report (Header). Called once by Writer()
    echo -e "Starting the Ubuntu Forums 'system-info' Report: $startt"
    echo -e '\tPart of the Ama-gi Project'    
    echo -e '\t'$version
    nl
    echo -e "---------------------------------------------------------------"
    echo -e "Main Complaint: $main_complaint"
    echo -e "Problem Description:  $problem_description"
    
    unset -v main_complaint problem_description
}

function MessageView()
{
    # Provides message at start of report. Called once by AdjustForLessStatus().
    echo -e "This output should first be ${setansi}viewed by less${ransi}, then sent to a file"
    nl
}

function MessageLess()
{
    # User Instructions for the 'less' utility. Called once by AdjustForLessStatus() and once by Writer() at end of report.
    echo -e "$redback ---------- INSTRUCTIONS FOR THE VIEWER 'LESS' ---------- $resetvid "
    echo -e "You are using the viewer 'less'."
    echo -e "Advance to a next page with the $blueback<SpaceBar>$resetvid key."
    echo -e "Navigate what has been displayed with the"
    echo -e "Left/Right/Up/Down Arrow, PageUp, PageDown, Home, or End keys."
    echo -e "If you are running within a graphical terminal session,"
    nl
    echo -e "you can also navigate with the mouse or touchpad."
    echo -e "Get more built-in help within 'less' with the <H> key."
    echo -e "At any point while in 'less' or if you see this '(END)' prompt"
    echo -e "at the lower left of your screen,"
    echo -e "$blueback quit from 'less' to continue the script with the <q> key. $resetvid"
    nl
    SensitiveDataWarning
 }
 
function MessageWait() 
{
    echo -e "Processing Report. This may take about 30 seconds."
    nl
}

function SensitiveDataWarning() 
{
    echo -e "$redback --- SENSITIVE DATA WARNING --- $resetvid "
    nl
    echo -e "This Report is prepared in two versions- "
    nl
    echo -e "The 'Your Eyes Only' version, only exists temporarily in memory, and is "
    echo -e "viewed onscreen by 'less'. The report that is viewed by 'less' onscreen "
    echo -e "contains 'sensitive data' that should NOT be posted publicly. "
    nl
    echo -e "The Final Report 'file' is saved to disk as a file. The Final Report is "
    echo -e "sanitized, filtered, with the sensitive data removed. It is safe to post "
    echo -e "online publicly. "
    nl
}
 
function ReportFooter()
{
    # End of report (the footer). Called once by Writer().
    echo -e "${setansi}*** End Of Report ***$ransi"
    if [ "$less_status" == "less" ]
    then
        MessageLess
    fi
}

function nl() 
{
    echo -e ""
}

function Pause()
{
    read -n 1 -s -r -p "Press any key to continue"
    nl
}

function PassPhrase() {
    read -erp "Press any key to continue:  " ans
    ans=$ans
    if [[ "$ans" == "I am Groot" ]]
    then
        echo -e "Running Script: ${sname} $version"
        sleep 0.2
    else
        echo -e "Exiting script"
        ResetLocale
        exit_code=106
        exit $exit_code
    fi
}

function ArchiveReport() {
    #Check if uploaded (successfully)...
    # $check-paste is 1 at start (not uploaed), 0 if upload was successful.
    uploaded=$check_paste  # Global Var
    report_size=$(wc -c $report | \
        awk '{print $1}')  # Local Var
    debug "Report size: $report_size" 1

    if [ $uploaded -eq 1 ] 
    then
        # Check size of report file, must be less than 19.5kB
        report_size=$(wc -c $report | \
            awk '{print $1}')  # Local Var
        debug "Report size: $report_size" 1
        if [ $report_size -ge 19500 ]
        then 
            echo -e "'${sname}.txt' is larger than 19.5kB. ($report_size bytes)"
            nl
            echo -e "If you want to attach to a post on Ubuntu Forums as an attachment, "
            echo -e "you will need to compress the report."
            nl
            # Prompt User       
            ans=
            while [ "$ans" != "y" ] && [ "$ans" != "Y" ] && [ "$ans" != "n" ] && [ "$ans" != "N" ]
            do
                read -erp "Would you like to archive the report? <y/N> " ans 
                ans="${ans,}" 
                debug "User answered $ans" 1
                if [[ $ans =~ ^[Yy]$ ]]
                then
                    echo -e "Compressing '${sname}.txt' to archive file '$HOME/${sname}.tar.gz'."
                    nl
                    # Remove old archive file, if present
                    if [ -f $HOME/${sname}.tar.gz ]
                    then 
                        rm -f  $HOME/${sname}.tar.gz
                    fi
                    cwd=$(pwd)    # Save current directory
                    cd $HOME
                    # Create Archive without any parent directories
                    tar -czvf ${sname}.tar.gz ${sname}.txt
                    exit_code=$?
                    # Check if archive was created successfully (catch exit code)
                    if [ $exit_code -eq 0 ]
                    then 
                        echo -e "Archive file can be found at '$HOME/$sname.tar.gz'."
                        nl
                        Pause
                    else
                        echo -e "$sname.txt was not compressed. Archive file not created."
                        nl
                        Pause
                        ResetLocale
                        exit 1
                    fi
                    cd $cwd
                elif [[ ${ans,} =~ ^[Nn]$ ]]
                then
                    if [ $verbosity -eq 5 ]
                    then 
                       debug "Continuing without creating archive file..." 1
                       sleep 1
                    fi
                fi

            done
        else
            echo "Report 'size' check complete. ($report_size bytes)"
            nl
            sleep 1
        fi
    fi
}

function Writer 
{
    # Report template. Called twice by Main().
    less_status="$1"
    debug "less_status: $less_status" 1
    AdjustForLessStatus
    ReportHeader
    GetMachineInfo    
    GetDiskInfo
    GetUsb
    GetGraphicsEnv
    GetSoundDevices
    GetRepositories
    GetKeyMap
    GetOtherDetails
    if [[ "$less_status" != "less" ]]
    then
        ProcessMissingPrograms
    fi
    ReportFooter
}

function PasteCurl()
{
    target="ix.io"
    return_url=$(printf "%s" "$(<$report)" | curl -F 'f:1=<-' $target )
    
    check_paste=$?
    debug "From PasteCurl()" 1
    debug "Response: $return_url Exit Code: $check_paste" 1;
}

function PastePastebinit()
{
    target="https://paste.ubuntu.com"
    return_url=$(pastebinit \
        -a "$USER" \
        -i "$report" \
        -b "$target" \
        -t "$sname.txt")
    check_paste=$?
    debug "From PastePasebinit()" 1
    debug "Response: $return_url Exit Code: $check_paste" 1;
}

function PasteWget()
{
    target="termbin.com:9999"
    return_url=$(wget --quiet -O- --post-data="$(cat $report)" $target | tr '\0' '\n' )
    check_paste=$?
    debug "From PasteWget()" 1
    debug "Response: $return_url Exit Code: $check_paste" 1;
}

function PasteNc()
{
    echo -e "This uses a program which sometimes conflicts with " 
    echo -e "Anti-Virus Programs. You should turn that off if you "
    echo -e "have installed."
    read -erp "Would you like to proceed or skip? (y/N) " ans
    if [[ ${ans,} =~ ^[Yy]$ ]]
    then
        target="termbin.com 9999"
        return_url=$(cat $report | nc $target | tr '\0' '\n')
        check_paste=$?
        debug "From PasteNc()" 1
        debug "Response: $return_url Exit Code: $check_paste" 1;
    else
        echo -e "You skipped uploading to Pastebin."
        check_paste=1
    fi
}

function CheckPasterProgs()
{
    # The order set here will set preference order.
    #     If you change the order here, reset the order in DoPaste() to match.
    if [ -e /usr/bin/pastebinit ]
    then
        paste_prog=1;
    elif [ -e /usr/bin/wget ]
    then
        paste_prog=2;
    elif [ -e /usr/bin/nc ] || [ -e /bin/nc ]
    then
        paste_prog=3;
    elif [ -e /usr/bin/curl ] || [ -e /snap/bin/curl ]
    then
        paste_prog=4;
    else
        paste_prog=0;
        echo -e "Many utilities were not found. Something is wrong.";
        debug "All progs used for paste where not found" 1
    fi
}

function DoPaste()
{
    prog_here=$1
    debug "Passed $prog_here" 1
    case "$prog_here" in
        1)
            PastePastebinit
            ;;
        2)
            PasteWget
            ;;
        3)
            PasteNc
            ;;
        4)
            PasteCurl
            ;;
        *)
            echo -e "Something went wrong. Error out of range."
            ResetLocale
            exit_code=105
            exit $exit_code
    esac    
}

function ProgressActive()
{
    # Provides a spinner to show progress. Called once by Paster.
    declare -a spinner=("\b|" "\b/" "\b-" "\b\\" "\b-")
    
    echo -ne '         '
    while test -f "$1"
     do
         for spin in "${spinner[@]}"
         do 
             stdbuf -oL echo -ne $spin 2> /dev/null
             sleep 0.2
         done
    done
    stdbuf -oL echo -en '\b '
}

function Paster() 
 {
     # Provides an upload of report with a progress bar. Called once by Main().
     target="a pastebin (URL depends on the method used)." # Var could be unset at end of this function...
     linklog="$HOME/${sname}-link.log"

     echo -e "$blueback Sensitive data is [REMOVED] from the report file $resetvid"
     CheckPasterProgs     
     ## Eval $paste_prog
     if [ $paste_prog -ne 0 ]
     then 
         read -erp "Do you want to upload the report file to a pastebin? (y/N) " ans
         if [[ ${ans,} =~ ^[Yy]$ ]]
         then
             GetPingStatus "www.ubuntu.com"
             if [ "$return_status" == "true" ]
             then
                 echo "Uploading '$report' to '$target'"
                 echo -e "This may take 1-2 minutes..."
                 nl
                 tput civis
                 keep_spinning=$(mktemp /tmp/keep_spinning-XXXXX)
                 ProgressActive "$keep_spinning" & pid_progressactive=$!
                 DoPaste $paste_prog
                 if [ $check_paste -eq 0 ]
                 then
                    paste_done=true
                 else
                    paste_done=false
                 fi
                 rm "$keep_spinning"
                 sleep 0.5
                 tput cnorm
                 debug "From Paster()" 1
                 debug "Paste_done: $paste_done" 1
                 if $paste_done
                 then
                     # Check $return_url for NULL
                     if [ "$return_url" != "" ]
                     then
                         echo -e "Uploaded Report: ${startt}:" >> "$linklog"
                         echo -e "$blueback Upload successful $resetvid"
                         nl
                         echo -e "The link to the pastebin is saved in: '$linklog'"
                         nl
                         echo -e "View at: $return_url" | tee -a "$linklog"
                         nl
                     else
                         echo -e "$redback Upload process failed $resetvid"
                         echo -e "The upload utility reported that the upload was susccessful, "
                         echo -e "but the host did not return a link to view it."
                         nl
                         echo -e "Upload the file manually: 'copy & paste' to"
                         echo -e "https://paste.ubuntu.com/"
                         nl
                         exit_code=101
                     fi
                 else
                     echo -e "$redback Upload failed $resetvid"
                     echo -e "Upload the file manually: 'copy & paste' to"
                     echo -e "https://paste.ubuntu.com/"
                     nl
                     exit_code=102
                 fi
             else
                    echo -e "No connection to an outside URL. " | tee -a "$linklog"
                    echo -e "Please copy the file $report to a USB and post "
                    echo -e "from a computer that does have a working connection."
                    echo -e "Upload the file manually: 'copy & paste' to"
                    nl
                    echo -e "https://paste.ubuntu.com/"
                    exit_code=103
             fi
         fi
    else
        echo -e "$redback    The required package was not installed.    $resetvid"
        nl
        echo -e "Either rerun the script after installing curl, or"
        echo -e "Upload the file manually: 'copy & paste' to"
        nl
        echo -e "https://paste.ubuntu.com/"
        nl
        exit_code=104
    fi
    unset -v target linklog keep_spinning
}

function ReportCleaner()
{
    # Clean the report from non-ascii characters. Called once by Main.
	report_original=$(mktemp /tmp/report_uncleaned-XXXXX)
	mv "$report" "$report_original"
	tr -cd '\11\12\40-\176' < "$report_original" > "$report"
	sleep 1
	# For debug purposes, comment out this next line
	rm "$report_original"
	#unset -v report_cleaned
}

# The following Basic Logger was based on public domain code 
#     from https://gist.github.com/goodmami/6556701 
# Rewritten by MAFoElffen, 2021.09.15
function notify() 
{
    logger $silent_lvl "NOTE: $1" $2; 
}

function critical() 
{
    logger $crt_lvl "CRITICAL: $1" $2; 
}

error() 
{ 
   logger $err_lvl "ERROR: $1" $2; 
}

warn() 
{ 
    logger $wrn_lvl "WARNING: $1" $2; 
}

inf() 
{ 
    logger $inf_lvl "INFO: $1" $2; 
}

debug() 
{ 
    logger $dbg_lvl "DEBUG: $1" $2; 
}

logger() 
{
    logfile=$HOME/$sname.log
    case "$3" in
        1)
            exec 3>&2     # logging stream (file descriptor 3) defaults to STDERR
            ;;
        2) 
            exec 3>> $logfile     # send to log file
            ;;
        3)
            exec 3>&2 | tee $logfile     # send to both logfile and screen
            ;;
        *)
            echo -e "Something went wrong. Log option out of range."
            ResetLocale
            exit 1
            ;;
    esac
    
    
    if [ $verbosity -ge $1 ]; then
        # Expand escaped characters, wrap at 70 chars, indent wrapped lines
        echo -e "$startt $2" | \
            fold -w70 -s | \
            sed '2~1s/^/  /' >&3
    fi
}


########################################################################
#### MAIN
########################################################################
## PreProcessing
CheckArgs    # Check external arguments: [<ScriptName> arg1]
CheckRoot    # Check if ran as root
CheckTypeError
#CheckPath ## <-- This currently breaks CheckPrerequisites()
CheckPrerequisites
## Report
UserInput
MessageWait
Writer less | \
    less -R    # writing to less
# For unknown reasons, but related to the pipe timing,  we need to waste a bit of time here
sleep 0.2
## Post processing
MessageWait
RmOldReport
#RestorePath ## This needed if we ever get CheckPath() working
Writer | \
    sed 's/<filter>/[REMOVED]/g' > \
    "$report"     # Writing to file
## Epitaph
echo "The result is stored in '$report'"
# Remove any Non-ASCII characters before Paster()
ReportCleaner
## Optional upload to various PasteBins
Paster
## Optional - Archive Report if size larger than 19.5k
ArchiveReport
ResetLocale
Pause  ## Put in to pause before exit, when using a file manager to run script.
exit $exit_code



########################################################################
## TODO LIST ##
########################################################################
# Continue to improve script, Report layout and UI
#
# Recheck all messages and prompts for spelling errors
#
# Add comments as script documentation:
#   - Document logic flow
#
# Add DEBUG statements:
#   - To be able to step through logic flow for maintenance.
# 
